# 《高性能MySQL》读书笔记

## 第1章 MySQL架构与历史

MySQL最重要、最与众不同的特性是它的存储引擎架构，这种架构将查询处理与数据的存储/提取相分离，使得可以在使用时根据不同的需求来选择数据存储的方式。

### MySQL逻辑架构
           客户端
 ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ ↓ 
+--------------------------+
-        连接/线程处理       -   // 连接处理、授权认证、安全
+--------------------------+
     ↓                ↓
+---------+      +---------+
- 查询缓存 -   ←  -  解析器  -   // 查询解析、优化、缓存、内置函数、存储过程、触发器、视图
+---------+      +---------+
                      ↓
+--------------------------+
-          优化器           -
+--------------------------+

+--------------------------+
-         存储引擎          -   // 数据的存储和提取
+--------------------------+

服务器通过API与存储引擎进行通信，这些API屏蔽了不同存储引擎之间的差异。存储引擎API包含几十个底层函数，不同存储引擎不会去解析SQL，而只是简单地响应上层服务器的请求。

每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个线程中执行，该线程只能轮流在某个CPU核心中运行。MySQL基于线程池来管理线程（创建、缓存、销毁）。

当客户端连接到MySQL服务器时，服务器会基于用户名、主机信息、密码等进行认证。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。

MySQL会解析查询并创建查询解析树，然后对其进行各种优化，如重写查询、决定表的读取顺序、选择合适的索引等。用户可以通过使用关键字提示优化器，从而影响它的决策过程。

优化器不关心表使用的是什么存储引擎，但`存储引擎对于优化查询是有影响的`：优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。

`对于SELECT语句`，在`解析查询之前`，服务器会先检查查询缓存，如果找到对应的查询，就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。

### 并发控制
加锁本身也需要消耗资源，锁策略就是在锁的开销和安全性之间寻求平衡。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。

`表锁`：会锁定整张表，在对表进行写操作之前，需要先获得写锁，获得写锁后将会阻塞其他用户对该表的读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不相互阻塞的。写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。

虽然不同的存储引擎都有自己的锁实现，MySQL自身仍然会在服务器层使用表锁并忽略存储引擎的锁机制，例如当执行ALTER TABLE时，`服务器`会使用表锁。

`行级锁`：行级锁只在存储引擎层实现，MySQL服务器层没有实现。

### 事务
ACID：atomicity(原子性)、consistency(一致性)、isolation(隔离性)、durability(持久性)。

隔离级别：SQL标准定义了4种隔离级别，每一种级别都规定了在一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。
1. `READ UNCOMMITED` 
事务中的修改，即使没有提交，对其他事务也是可见的。（因此会产生脏读）
2. `READ COMMITTED`
一个事务只能看见已经提交的事务所做的修改。
3. `REPEATABLE READ`
这是MySQL默认的事务隔离级别，保证在同一个事务中多次读取同样记录的结果是一样的。理论上该级别无法避免幻读的问题，InnoDB通过多版本并发控制解决了幻读的问题。
4. `SERIALIZABLE`
强制事务串行执行，会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用问题。

可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：
SET SESSION TRANSACTION LEVEL READ COMMITTED;

死锁：当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。（两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环）对于事务型的系统，死锁发生后，只有部分或者完全回滚其中一个事务，才能打破死锁。InnoDB目前处理死锁的方式是：在检测到死锁循环依赖后，将持有最少行级排它锁的事务进行回滚。

事务日志：事务日志可以帮助提高事务的效率，存储引擎在修改表的数据时只需要修改表数据的内存拷贝，同时把该修改行为持久化到硬盘中的事务日志中，相比于将修改的数据本身持久化到磁盘，事务日志采用的是追加的方式，因此是在磁盘上的一小块区域内顺序地写入，而不是随机的I/O操作。事务日志持久化后，内存中被修改的数据在后台可以慢慢刷回磁盘，如果在数据没有写回磁盘时系统崩溃了，存储引擎在重启时能够自动恢复这部分数据。目前大多数存储引擎都是这样实现的。

MySQL默认采用自动提交模式，如果不是显式地开始一个事务，则每个查询都会被当做一个事务执行提交操作。可以在当前连接中设置`AUTOCOMMIT`变量来禁用自动提交模式(禁用后，需要显式地执行COMMIT提交或者ROLLBACK回滚)。对于非事务型的表，修改AUTOCOMMIT不会有任何影响，这类表相当于一直处于AUTOCOMMIT启用的状态。
此外，有一些命令，例如ALTER TABLE，在执行之前会强制执行COMMIT提交当前的活动事务。

如果在事务中混合使用了事务型和非事务型的表，当事务需要回滚时，非事务型表上的变更将无法撤销，这将导致数据库处于不一致的状态。在非事务型表上执行事务相关操作时，MySQL通常并不会报错，只会给出一些警告。

显式锁定：MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，但它们不能代替事务处理，如果应用到事务，还是应该选择事务型存储引擎。
（建议：除了在事务中禁用了AUTOCOMMIT时可以使用LOCK TABLE之外，其他任何时候都不要显式地执行LOCK TABLES，不管使用的是什么存储引擎，因为LOCK TABLE和事务之间相互影响时，问题会变得非常复杂）

InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL规范，如：
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE

### 多版本并发控制
可以认为MVCC是行级锁的一个变种，但是它在很多情况下都避免了加锁操作，因此开销更低（更高并发）。其实现原理是通过保存数据在某个时间点的快照来实现的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的，这两个列一个保存行的创建版本号，一个保存行的过期版本号，每开始一个新的事务，系统版本号就会自动递增。事务开始时刻的版本号会作为事务的版本号用来和查询到的每行记录的版本号进行比较。
MVCC只在REPEATABLE和READ COMMITED两个隔离级别下工作，其他两个隔离级别和MVCC不兼容。
（在不同隔离级别下，每种查询的具体行为，略）

### MySQL的存储引擎
MySQL将每个数据库保存为数据目录下的一个子目录，创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件来保存表的定义。
可以使用SHOW TABLE STATUS命令或者查询INFOMATION_SCHMA中对应的表来显示某个表的相关信息。
InnoDB在95%的情况下都是最好的选择。
（InnoDB、MyISAM、其他内建及第三方引擎概述，略）

### MySQL时间线
（即版本变更历史，略）

### MySQL的开发模式
（开发过程和发布模型，略）


## MySQL基准测试
基准测试是针对系统设计的一种压力测试，通常的目标是为了`掌握系统的行为`。

### 基准测试的策略
两种主要策略：针对系统的整体测试，单独测试MySQL。

`测试指标`：
1.吞吐量：单位时间内的事务处理数；
2.响应时间（延迟）：完成测试任务所需的时间；（95%法则）
3.并发性：测试应用在不同并发下的性能；
4.可扩展性：线性扩展；

### 基准测试方法
（常见的测试设计错误，略）

### 基准测试工具
ab、http_load、JMeter
mysqlslap、MySQL Benchmark Suite、Super Smack...
(工具介绍，略)

### 基准测试案例
（略）



## 第3章 服务器性能剖析
性能：完成某件任务所需要的时间度量，性能即响应时间。
性能剖析（profiling）：测量服务器的时间花费在哪里。
性能剖析的步骤：测量任务所花费的时间，然后对结果进行统计和排序，将重要的任务排到前面。

### 对应用程序进行性能剖析
使应用的可测量，性能剖析的代码会导致服务器变慢，可以采用`随机采样`：
```
<?php
$profiling_enabled = rand(0,100) > 99;
...
```

（PHP程序的性能测试，推荐facebook的xhprof，详略）

### 剖析MySQL查询
在MySQL中可以通过设置long_query_time为0来捕获所有的查询，目前查询的相应时间单位已经精确到微秒级。

在MySQL中，慢查询日志是开销最低、精度最高的测量查询时间的工具。对CPU的开销很少，但是可能消耗大量的磁盘空间。

也可以通过tcpdump抓取TCP包，然后使用pt-query-digest --type=tcpdump选项来解析并分析查询。

（使用pt-query-digest解析慢查询日志，略）

剖析单条查询：
```
SET profiling = 1;
SELECT * ...
SHOW PROFILES;               # 所有查询的统计
SHOW PROFILE FOR QUERY 1;   # 单条查询的详情，给出查询执行的每个步骤及花费的时间
```
也可以不使用SHOW PROFILE命令，而是直接查询INFOMATION_SCHEMA中对应的表，这样可以自定义输出数据的格式（按特定字段排序等）。

可以使用SHOW STATUS命令返回查询计数器（但无法给出消耗了多少时间）。最有用的计数器是句柄计数器、临时文件、表计数器等。
```
FLUSH STATUS;
SELECT * FROM ...
SHOW STATUS WHERE Variable_name LIKE 'Handler%' OR Variable_name LIKE 'Created';
```
SHOW STATUS本身也会创建一个临时表，而且也会通过句柄操作访问此临时表，也会影响到SHOW STATUS结果中对应的数字。

`Performance Schema`：5.5中新增，目前还在快速开发中

### 诊断间歇性问题
（案例，略）

### 其他剖析工具
（略）


## 第4章 Schema与数据类型优化

### 选择优化的数据类型

选择数据类型的几个简单原则：
1.更小的通常更好；
2.简单就好：整型操作比字符型操作代价低；使用整型存储IP地址；
3.尽量避免NULL：可为NULL的列需要更多的存储空间，在索引优化时也更复杂（需要记录额外的字节）；（InnoDB使用单独的bit存储NULL值，这对于稀疏数据有很好的空间效率）

TIMESTAMP只使用DATATIME一半的存储空间，且会根据时区自动更新，但是它允许的范围要小很多（1970年开始）。

MySQL中的INTEGER、BOOL等只是基本类型的别名，如果用这些名字建表，SHOW CREATE TABLE仍然显示基本类型。

MySQL可以为整数类型指定宽度，例如INT(11),但这实际并不会限制值的合法范围，作用只是规定了MySQL的一些交互工具用来显示字符的个数，对于存储和计算来说，INT(1)和INT(20)是相同的（都是11位）。其他整型数同理。

TINYINT的存储空间为`8位`，存储值范围为-128~127，TINYINT UNSIGNED的存储范围是0~255；

VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于等于255，则只使用1个字节，否则使用2个字节，所以一个VARCHAR(10)的列需要11个字节的存储空间，VARCHAR(1000)的列则需要1002个字节。

比较适合使用VARCHAR类型的情况：
1.字符串的最大长度比平均长度大很多；
2.列的更新很少；（更新导致长度变化，会有额外的更新操作）
3.使用了像UTF-8这样的复杂字符集，每个字符使用不同的字节数进行存储；

InnoDB可以把过长的VARCHAR存储为BLOB；

MySQL把BLOB和TEXT值当做独立的对象处理，当其太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

如果使用完全随机的字符串作为标识列，例如使用MD5值，会导致INSERT以及UPDATE语句变得很慢，原因可能有：
1.插入值会随机地写到索引的不同位置，使得INSERT语句更慢，会导致页分裂，磁盘随机访问，产生聚簇索引碎片；
2.SELECT会更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方；
3.随机值导致缓存对所有类型的查询语句效果都很差；（局部性原理失效）

（其他类型，略）


### MySQL schema设计中的陷阱
1.太多的列：存储引擎API需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个操作的代价非常高，而转换的代价依赖于列的数量。
2.太多的关联：对于MySQL来说，EAV（实体-属性-值）设计模式是一个糟糕的设计模式，MySQL限制了每个关联操作最多只能有61张表。经验表明，单个查询最好在12个表以内做关联。

### 范式和反范式
（范式、反范式各自的优缺点，略）
完全的范式化和完全的反范式化schema都是实验室里才有的东西，在实际应用中经常需要混用。

### 缓存表和汇总表
缓存表：存储那些可以比较简单地从schema其他表获取数据的表（存在逻辑上冗余的数据）；
汇总表：保存使用GROUP BY语句聚合数据的表；

MySQL原生不支持物化视图，但是可以通过插件实现。

使用随机方式实现计数器表：如下的网站点击统计计数器表存在并发问题：
```
CREATE TABLE hit_counter(
  cnt int unsigned not null
) ENGINE=InnoDB;
```
当网站发生点击时：
```
UPDATE hit_counter SET cnt = cnt + 1;
```
要获得更高的并发更新性能，可以将数据器保存在多行中，每次随机选择一行进行更新，修改计数器表如下：
```
CREATE TABLE hit_counter(
  slot tinyint unsigned not null primary key,
  cnt int unsigned not null
)ENGINE=InnoDB;
```
当发生更新操作时，选择一个随机的行进行更新：
```
UPDATE hit_counter SET cnt = cnt + 1 WHERE slot = RAND() * 100;
```
如下获取统计结果：
```
SELECT SUM(cnt) FROM hit_counter;
```

### 加快ALTER TABLE操作的速度
常规的方法是建另一张结构符合要求的表，并插入旧表的数据，然后切换主从，或者切换新旧表。
修改表的.frm文件是很快的，因此可以为想要创建的表结构创建一个新的.frm文件，然后用它替换掉已经存在的表的.frm文件。（详略）

### 在有索引的情况下快速导入表数据
常规的方法：
1.先删除索引：如ALTER TABLE t.data DISABLE KEYS;  # 对唯一索引无效
2.导入数据
3.再创建索引：如ALTER TABLE t.data ENABLE KEYS; 

hack方法是直接修改.MYD、.frm、.MYI等文件，详略。


## 第5章 创建高性能索引

### 索引基础
在MySQL中，索引是在存储引擎层而不是服务器层实现的，并没有统一的索引标准，不同的存储引擎索引工作的方式是不一样的。

### 索引类型
1.`B-Tree索引`
意味着所有的索引都是按顺序存储的，并且每一个叶子页到根的距离相同。
B-Tree索引可应用于如下类型的查询：
（1）全值匹配：和索引中的所有列进行匹配；
（2）匹配最左前缀：如当索引有多列时，只使用索引的第一列；
（3）匹配列前缀：只使用索引第一列的值的开头部分；
（4）匹配范围值：只使用索引的第一列；
（5）精确匹配某一列，并范围匹配另一列：只使用索引的第一列及第二列的开头部分；
（6）只访问索引的查询：查询只需要访问索引，而无须访问数据行，即`覆盖索引`；
（7）可用于ORDER BY查询；

B-Tree索引的限制：
（1）如果不是按照索引的最左列开始查找，则无法使用索引；
（2）不能跳过索引中的列；
（3）如果查询中有某个列的范围查询（包括LIKE等），则其右边所有列都无法使用索引优化查找；


2.`哈希索引`
基于哈希表实现，对于每一行数据存储引擎都会对所有的索引列计算一个哈希码，只有精确匹配索引所有列的查询才有效。
只有Memory引擎显式支持哈希索引。（详略）

InnoDB有一个特殊的功能：`自适应哈希索引`，当InnoDB注意到某些索引值被使用得非常频繁时，就会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。


3.空间数据索引（R-Tree）
MyISAM表支持空间索引，可以用作地理数据存储。


4.全文索引
查找的是文本中的关键词，而不是直接比较索引中的值。适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

### 索引的优点
1.减少服务器需要扫描的数据量；
2.避免排序和临时表；
3.将随机I/O变为顺序I/O；

### 高性能的索引策略
1.如果查询中的列不是独立的，而是表达式的一部分，MySQL将不会使用索引；
```
 # 如下情况下不会使用索引
 SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

2.索引的选择性越高则查询的效率越高；（索引选择性 = 列取值基数/表记录总数）
```
 # 计算列的选择性
 SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
```

3.可以使用前缀索引来替代对很长的字符列做索引；
```
 # 计算不同前缀长度的索引的选择性
 SELECT 
   COUNT(DISTINCT LEFT(city,3))/COUNT(*) AS sel3,
   COUNT(DISTINCT LEFT(city,4))/COUNT(*) AS sel4,
   ...
   COUNT(DISTINCT LEFT(city,7))/COUNT(*) AS sel7,
FROM sakila.city_demo;

 # 添加前缀索引
ALTER TABLE sakila.city_demo ADD KEY(city(7));
```
MySQL不能使用前缀索引做ORDER BY和GROUP BY查询，也无法使用前缀索引做覆盖扫描。


4.在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能：
（1）当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的多列索引；
（2）当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要消耗大量的CPU和内存资源用在缓存、排序和合并操作上。而且优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取，这会导致查询的成本被低估，`甚至该执行计划还不如直接走全表扫描`。这样的查询通常通过改写成UNION查询来优化：
```
 # 假设actor_id和film_id这两列上都有独立的索引
SELECT film_id,actor_id FROM sakila.film_actor
  WHERE actor_id = 1 OR film_id = 1;
```
改写成：
```
SELECT film_id,actor_id FROM sakila.film_actor
  WHERE actor_id = 1
UNION ALL
SELECT film_id,actor_id FROM sakila.film_actor
  WHERE actor_id <> 1 AND film_id = 1;
```

5.多列索引的列顺序非常重要，在一个多列的B-Tree索引中，索引总是先按照最左列进行排序，其次是第二列，等等。
经验：一般的选择是将选择性最高的列放到索引最前列，但是避免随机IO和排序通常更为重要，所以要优先结合值的分布情况及频繁执行的查询场景来考虑。


### 聚簇索引
聚簇索引并不是一种单独的索引类型，而是`一种数据存储方式`。InnoDB的聚簇索引实际上是在同一个结构中保存了B-Tree索引（主键）和数据行。
`聚簇`表示数据行和键值紧凑地存储在一起，一个表只能有一个聚簇索引。

如果没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

聚簇索引的优点：
（1）可以将相关数据保存在一起；
例如根据用户ID来聚集数据，这样只要从磁盘读取少数的数据页就能获取某个用户的全部记录，如果没有使用聚簇索引，则每条记录都可能导致一次磁盘I/O。
（2）数据访问更快：
因为索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。
（3）使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

聚簇索引的缺点：
（1）如果数据全部都放在内存中，则访问顺序就不那么重要了，聚簇索引也就没什么优势了；
（2）插入速度严重依赖于插入顺序；如果不是按照主键顺序插入数据，在插入完成后最好执行OPTIMIZE TABLE重新组织表；
（3）更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置；
（4）当行的主键要求必须将一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，即造成“页分裂”，导致表占用更多的磁盘空间。
（5）聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续时；
（6）非聚簇索引会更大，因为在非聚簇索引的叶子节点中包含了引用行的主键列；
（7）非聚簇索引访问需要两次索引查找，而不是一次；（非聚簇索引的叶子节点保存的不是指向行的物理位置的指针，而是行的主键值），对于InnoDB，自适应哈希索引能够减少这样的重复工作。


### InnoDB和MyISAM的数据分布对比
InnoDB中聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键和剩下的其他列。
（详略）

使用InnoDB时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新行。


### InnoDB顺序主键的高并发问题
在高并发情况下，在InnoDB中按主键顺序插入可能会导致明显的争用，当前主键的上界会成为“热点”，导致锁竞争。
此外AUTO_INCREMENT锁机制（表锁）也会导致竞争。可以通过修改innodb_autoinc_lock_mode来优化：
innodb_autoinc_lock_mode = 0 ("traditional" lock mode：全部使用表锁)
innodb_autoinc_lock_mode = 1 (默认)("consecutive" lock mode：可`预判行数`时使用新方式，不可时使用表锁) 
innodb_autoinc_lock_mode = 2 ("interleaved" lock mode：全部使用新方式，不安全，不适合replication)


### 覆盖索引
覆盖索引：索引包含，或者说覆盖所有需要查询的字段的值。
MySQL只能使用B-Tree索引做覆盖索引。

使用了覆盖索引的查询，在EXPLAIN的Extra列可以看到`Using index`的信息。

### 使用索引排序
只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能使用索引对结果做排序。
如果查询关联了多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。

有一种情况下ORDER BY子句可以在不满足索引的最左前缀要求的情况下使用索引进行排序：前导列在where中被设置为常量。

假设有如下索引：
```
PRIMARY KEY(rental_id),
UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),
KEY idx_fk_inventory_id(inventory_id),
KEY idx_fk_customer_id(customer_id),
KEY idx_fk_staff_id(staff_id),
```

以下查询可以使用索引做排序：
```
 # 因为索引前导列在WHERE中被设置为常量
...WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC;  

 # ORDER BY使用的两列就是索引的最左前缀
...WHERE rental_date > '2005-05-25' ORDER BY rental_date,inventory_id;  
```

以下查询不能使用索引做排序：
```
 # 排序方向不同
...WHERE rental_date = '2005-05-25' ORDER BY inventory_id DESC,customer_id ASC; 

 # 使用了不在索引中的列
...WHERE rental_date = '2005-05-25' ORDER BY inventory_id,staff_id; 

 # WHERE和ORDER BY中的列无法组合成索引的最左前缀
...WHERE rental_date = '2005-05-25' ORDER BY customer_id; 

 # 在索引列的第一列上使用的是范围条件，所以无法使用索引的其余列
...WHERE rental_date > '2005-05-25' ORDER BY inventory_id,customer_id; 

 # 在前置索引列上使用了范围查找
...WHERE rental_date = '2005-05-25' AND inventory_id IN(1,2) ORDER BY customer_id; 
```

### 压缩索引
MyISAM支持索引压缩，略。


### 冗余和重复索引
重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该避免这样创建重复索引。

### 未使用的索引
使用pt-index-usage读取查询日志，统计各种索引的使用情况。

### 索引和锁
InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。

Extra中的"Using where"表示在存储引擎层未能实现过滤，InnoDB检索到数据并返回服务器层以后，MySQL服务器才能应用WHERE子句，这种情况下会对这些不满足WHERE条件的数据行也加锁（因为这种情况下存储引擎的操作是`从索引的开头开始`获取满足条件的记录）。

即使使用了索引，InnoDB也可能锁住一些不需要的数据，如果不能使用索引查找和锁定行，MySQL会做全表扫描并锁住所有的行，而不管是不是需要。

执行：
```
SET AUTOCOMMIT = 0;
BEGIN;
SELECT actor_id FROM sakila.actor WHERE actor_id < 5 AND actor_id <> 1 FOR UPDATE;
```
如上查询语句在存储引擎层的操作是“从索引的开头开始获取满足条件actor_id < 5的记录”，此时再执行如下语句，将被挂起：
```
SET AUTOCOMMIT = 0;
BEGIN;
SELECT actor_id FROM sakila.actor WHERE actor_id = 1 FOR UPDATE;
```

InnoDB在二级索引上使用共享锁（读锁），但在访问主键时使用排它锁（写锁）。


### 案例学习
（略）


### 维护索引和表
当碰到古怪的问题，比如不应该发生的主键冲突等等，可以通过CHECK TABLE来检查是否发生了表损坏。该命令通常能够找出大多数表和索引的错误。
可以执行REPAIR TABLE来修复损坏的表。
也可以通过一个不做任何数据操作的ALTER操作来重建表，以达到修复的目的：
```
ALTER TABLE innodb_tbl ENGINE=INNODB;
```

（详略）



## 第6章 查询性能优化

### 常见的导致查询过慢的原因
1.查询不需要的记录；如误以为MySQL会只返回需要的数据，实际上却是先返回全部结果集，再进行计算。
2.多表关联时返回全部列，如:
```
SELECT * FROM sakila.actor
  INNER JOIN sakila.film_actor USING(actor_id)
  INNER JOIN sakila.film USING(film_id)
  WHERE sakila.film.title = '***';
```
该查询将会返回三个关联表的全部数据列，正确的方式应该是只取需要的列：
```
SELECT sakila.actor.* FROM sakila.actor...;
```
3.总是取出全部列：SELECT * FROM ...
4.重复查询相同的数据，而不是使用缓存；


### MySQL使用WHERE条件的不同方式
从好到坏依次为：
1.在索引中使用WHERE条件来过滤不匹配的记录，这是在存储引擎层完成的；
2.使用索引覆盖扫描（Using index）返回记录，直接从索引中过滤不需要的记录并返回命中的结果，在MySQL服务器层完成，无需再回表查询记录；
3.从数据表中返回数据，然后过滤不满足条件的记录（Using Where），MySQL需要先从数据表读出记录然后过滤；

### 重构查询的方式
































---
layout: post
title:  "问题总结：Java"
date: 2017-04-05 00:00:05
categories: 问题总结
tags: Java
excerpt: ""
---

* content
{:toc}


# ==与equals的区别

**==比较的是引用而equals方法比较的是内容**。
```java
public boolean equals(Object obj) 
```
这个方法是由Object对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回true,这个时候和==是等价的。String, BitSet, Date, 和File都对equals方法进行了重写，对两个String对象 而言，值相等意味着它们包含同样的字符序列。对于基本类型的包装类来说，值相等意味着对应的基本类型的值一样。



# char型变量中能不能存贮一个中文汉字?为什么?

char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16bit），所以放一个中文是没问题的。

**补充**：使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在JVM内部都是Unicode，当这个字符被从JVM内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以Java中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；对于C程序员来说，要完成这样的编码转换恐怕要依赖于union（联合体/共用体）共享内存的特征来实现了。



# Comparable和Comparator接口是干什么的？

Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。
Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。



# final, finally, finalize的区别

final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final 的方法也同样只能使用，不能在子类中被重写。finally：通常放在try…catch的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。



# final关键字有哪些用法？

* 修饰类：表示该类不能被继承；
* 修饰方法：表示方法不能被重写；
* 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。



# GC理解

Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：`System.gc()`或`Runtime.getRuntime().gc()` ，但JVM可以屏蔽掉显式的垃圾回收调用。
垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在Java诞生初期，垃圾回收是Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今Java的垃圾回收机制已经成为被诟病的东西。移动智能终端用户通常觉得iOS的系统比Android系统有更好的用户体验，其中一个深层次的原因就在于Android系统中垃圾回收的不可预知性。

**补充**：垃圾回收机制有很多种，包括：分代复制垃圾回收、标记垃圾回收、增量垃圾回收等方式。标准的Java进程既有栈又有堆。栈保存了原始型局部变量，堆保存了要创建的对象。Java平台对堆内存回收和再利用的基本算法被称为标记和清除，但是Java对其进行了改进，采用“分代式垃圾收集”。这种方法会根据Java对象的生命周期将堆内存划分为不同的区域，在垃圾收集过程中，可能会将对象移动到不同区域：

* 伊甸园（Eden）：这是对象最初诞生的区域，并且对大多数对象来说，这里是它们唯一存在过的区域。
* 幸存者乐园（Survivor）：从伊甸园幸存下来的对象会被挪到这里。
* 终身颐养园（Tenured）：这是足够老的幸存对象的归宿。年轻代收集（Minor-GC）过程是不会触及这个地方的。当年轻代收集不能把对象放进终身颐养园时，就会触发一次完全收集（Major-GC），这里可能还会牵扯到压缩，以便为大对象腾出足够的空间。

与垃圾回收相关的JVM参数：

* -Xms / -Xmx --- 堆的初始大小 / 堆的最大大小
* -Xmn --- 堆中年轻代的大小
* -XX:-DisableExplicitGC --- 让System.gc()不产生任何作用
* -XX:+PrintGCDetail --- 打印GC的细节
* -XX:+PrintGCDateStamps --- 打印GC操作的时间戳



# Hashmap如何同步?

当需要一个同步的HashMap时，有两种选择：

* 使用`Collections.synchronizedMap（..）`来同步HashMap。
* 使用`ConcurrentHashMap`

这两个选项之间的首选是使用ConcurrentHashMap，这是因为不需要锁定整个对象，以及通过ConcurrentHashMap分区地图来获得锁。



# IdentityHashMap和HashMap的区别

IdentityHashMap是Map接口的实现。不同于HashMap的，这里采用参考平等。

* 在HashMap中如果两个元素是相等的，则`key1.equals(key2)`
* 在IdentityHashMap中如果两个元素是相等的，则`key1 == key2`




# int和Integer的区别

Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入不是对象的基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。
Java 为每个原始类型提供了包装类型：
```
原始类型: boolean，char，byte，short，int，long，float，double
包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double
```



# Java中`List<?>`和`List<Object>`之间的区别

`List<?>` 是一个未知类型的List，而`List<Object>`其实是任意类型的List。可以把`List<String>`, `List<Integer>`赋值给`List<?>`，却不能把`List<String>`赋值给`List<Object>`。  

```java    
List<?> listOfAnyType;
List<Object> listOfObject = new ArrayList<Object>();
List<String> listOfString = new ArrayList<String>();
List<Integer> listOfInteger = new ArrayList<Integer>();
      
listOfAnyType = listOfString; //legal
listOfAnyType = listOfInteger; //legal
listOfObjectType = (List<Object>) listOfString; //compiler error - in-convertible types
```



# Java中`List<Object>`和原始类型List之间的区别 

原始类型和带参数类型<Object>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer。这道题的考察点在于对泛型中原始类型的正确理解。它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把List<String>传递给接受List<Object>的方法，因为会产生编译错误。



# Java中会存在内存泄漏吗

理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。下面的例子也展示了Java中发生内存泄露的情况：

```java
import java.util.Arrays;  
import java.util.EmptyStackException;  
  
public class MyStack<T> {  
   	private T[] elements;  
    private int size = 0;  
      
    private static final int INIT_CAPACITY = 16;  
      
    public MyStack() {  
        elements = (T[]) new Object[INIT_CAPACITY];  
    }  
      
    public void push(T elem) {  
        ensureCapacity();  
        elements[size++] = elem;  
    }  
      
    public T pop() {  
        if(size == 0)   
            throw new EmptyStackException();  
        return elements[--size];  
    }  
      
    private void ensureCapacity() {  
        if(elements.length == size) {  
            elements = Arrays.copyOf(elements, 2 * size + 1);  
        }  
    }  
}  
```
上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。 



# Java中如何实现序列化，有什么意义？

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。
要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object obj)方法就可以将实现对象写出(即保存其状态)；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆.



# Java字节流与字符流的区别

实际上字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件。
可以简单地把缓冲区理解为一段特殊的内存。
某些情况下，如果一个程序频繁地操作一个资源（如文件或数据库），则性能会很低，此时为了提升性能，就可以将一部分数据暂时读入到内存的一块区域之中，以后直接从此区域中读取数据即可，因为读取内存速度会比较快，这样可以提升程序的性能。在字符流的操作中，所有的字符都是在内存中形成的，在输出前会将所有的内容暂时保存在内存之中，所以使用了缓冲区暂存数据。
如果想在不关闭时也可以将字符流的内容全部输出，则可以使用Writer类中的flush()方法完成。



# Java的反射(reflection)机制理解

```java
interface	A
{
	int x = 0;
}
class B
{
	int x =1;
}
class C extends B implements A
{
	public void pX()
{
		System.out.println(x);
	}
public static void main(String[] args) {
  	new C().pX();
	}
}
```
在编译时会发生错误(错误描述不同的JVM有不同的信息，意思就是未明确的x调用，两个x都匹配（就象在同时import java.util和java.sql两个包时直接声明Date一样）。对于父类的变量,可以用super.x来明确(输出的是1)，而接口的属性默认隐含为 public static final.所以可以通过A.x来明确(输出的是0)。



# Java的泛型是如何工作的?

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。



# JVM加载class文件的原理机制

JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
补充：

* 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接(验证、准备和解析)和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤。最后JVM对类进行初始化，包括：1如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2如果类中存在初始化语句，就依次执行这些初始化语句。
* 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从JDK 1.2开始，类加载过程采取了父亲委托机制(PDM)。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。

下面是关于几个类加载器的说明：
* Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
* Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
* System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。

# Math.round
`Math.round(11.5)`等于多少？`Math.round(-11.5)`等于多少？ 
```
12 ,-11
```
四舍五入四和五是指正的4，5
-11.5 这么看 -11.5 = -12 +0.5   ，0.5按四舍五入为1 ，-12+1 = -11，所以Math.round(-11.5)==-11
-0.5 = -1 + 0.5   0.5按四舍五入为1 ，-1+1 = 0，所以Math.round(-0.5)==0
11.5 四舍五入 显然 Math.round(11.5)==12
round方法返回与参数最接近的长整数，参数加0.5后求其floor（小于等于该数的最大整数）



# public、static、void
说明一下
```
public static void main(String args[])
```
这段声明里每个关键字的作用：
* public: main方法是Java程序运行时调用的第一个方法，因此它必须对Java环境可见。所以可见性设置为pulic.
* static: Java平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为static。
* void: main方法没有返回值。
  String是命令行传进参数的类型，args是指命令行传进的字符串数组。

# short
`short s1 = 1; s1 = s1 + 1;`有错吗?`short s1 = 1; s1 += 1;`有错吗? 
对于
```
short s1 = 1; s1 = s1 + 1;
```
由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型。
而
```
short s1 = 1; s1 += 1;
```
可以正确编译，因为`s1+= 1;`相当于`s1 = (short)(s1 + 1);`其中有隐含的强制类型转换。


# sleep()和wait()有什么区别? 
sleep()方法是线程类（Thread）的静态方法，导致此线程暂停执行指定时间，将执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复（线程回到就绪（ready）状态），因为调用sleep 不会释放对象锁(也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据)。wait()是Object 类的方法，对此对象调用wait()方法导致本线程放弃对象锁(线程暂停执行)，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入就绪状态。

# sleep()和yield()有什么区别?
* sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
* 线程执行sleep()方法后转入阻塞（blocked）状态(sleep结束后恢复到ready状态，而不是直接执行)，而执行yield()方法后转入就绪（ready）状态；
* sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
* sleep()方法比yield()方法（跟操作系统相关）具有更好的可移植性。

# String，StringBuffer与StringBuilder的区别
* String 字符串常量
* StringBuffer 字符串变量（线程安全）
* StringBuilder 字符串变量（非线程安全）

简要的说，String类型和StringBuffer类型的主要性能区别其实在于String是不可变的对象, 因此在每次对String类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM的GC就会开始工作，那速度是一定会相当慢的。
而如果是使用StringBuffer类则结果就不一样了，每次结果都会对StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被JVM解释成了StringBuffer对象的拼接，所以这些时候String 对象的速度并不会比StringBuffer对象慢，而特别是以下的字符串对象生成中，String效率是远要比StringBuffer快的。



# swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上?

早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。



# synchronized关键字的用法？

synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。



# transient和volatile是java关键字吗

是。
如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。例如：

```java 
class T 
{   
  transient int a;  //不需要维持 
  int b;  //需要维持
}  
```
这里，如果T类的一个对象写入一个持久的存储区域，a的内容不被保存，但b的将被保存。 
volatile修饰符告诉编译器被volatile修饰的变量可以被程序的其他部分改变。在多线程程序中，有时两个或更多的线程共享一个相同的实例变量。考虑效率问题，每个线程可以自己保存该共享变量的私有拷贝。实际的变量副本在不同的时候更新，如当进入synchronized方法时。 



# try、return

try{}里有一个return语句，那么紧跟在这个try后的finally{}里的code会不会被执行，什么时候被执行，在return前还是后?
会执行，在方法返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，这会对程序造成很大的困扰，C#中就从语法上规定不能做这样的事。

Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throw）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try用来指定一块预防所有“异常”的程序；catch 子句紧跟在try块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws用来标明一个成员函数可能抛出的各种“异常”；finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种“异常”进行处理，栈就会展开，直到遇到有处理这种“异常”的try 语句。



# 一个.java源文件中是否可以包含多个类（不是内部类）？
可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。


# 为什么调用start()方法时会执行run()方法，为什么不能直接调用run()方法？
当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。

# 什么时候用assert？
assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式计算为false，那么系统会报告一个AssertionError。
断言用于调试目的：
```
assert(a > 0); // throws an AssertionError if a <= 0
```
断言可以有两种形式：
```
assert Expression1;
assert Expression1 : Expression2 ;
```
Expression1 应该总是产生一个布尔值。
Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。
断言在默认情况下是禁用的，要在编译时启用断言，需使用source 1.4 标记：
```
javac -source 1.4 Test.java
```
要在运行时启用断言，可使用-enableassertions 或者-ea 标记。
要在运行时选择禁用断言，可使用-da 或者-disableassertions 标记。
要在系统类中启用断言，可使用-esa 或者-dsa 标记。还可以在包的基础上启用或者禁用断言。可以在预计正常情况下不会到达的任何位置上放置断言。断言可以用于验证传递给私有方法的参数。不过，断言不应该用于验证传递给公有方法的参数，因为不管是否启用了断言，公有方法都必须检查其参数。不过，既可以在公有方法中，也可以在非公有方法中利用断言测试后置条件。另外，断言不应该以任何方式改变程序的状态。

# 什么是不可变对象
**可变类和不可变类(Mutable and Immutable Objects)的初步定义**：
* 可变类：当你获得这个类的一个实例引用时，你可以改变这个实例的内容。
* 不可变类：当你获得这个类的一个实例引用时，你不可以改变这个实例的内容。不可变类的实例一但创建，其内在成员变量的值就不能被修改。 

**如何创建一个自己的不可变类**：
* 所有成员都是private
* 不提供对成员的改变方法，例如：setXXXX
* 确保所有的方法不会被重载。手段有两种：使用final Class(强不可变类)，或者将所有类方法加上final(弱不可变类)。
如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。

**jdk的可变类和不可变类：**
* primitive变量: boolean,byte, char, double ,float, integer, long, short 
* jdk的不可变类：jdk的java.lang包中 Boolean, Byte, Character, Double, Float, Integer, Long, Short, String. 
* StringBuffer 可变类
* java.util.Date 可变类


# 什么是泛型中的限定通配符和非限定通配符?

限定通配符对类型进行了限制。有两种限定通配符，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面<?>表示了非限定通配符，因为<?>可以用任意类型来替代。更多信息请参阅我的文章泛型中限定通配符和非限定通配符之间的区别。

# 你可以把List<String>传递给一个接受List<Object>参数的方法吗？

对任何一个不太熟悉泛型的人来说，这个Java泛型题目看起来令人疑惑，因为乍看起来String是一种Object，所以List<String>应当可以用在需要List<Object>的地方，但是事实并非如此。真这样做的话会导致编译错误。如果你再深一步考虑，你会发现Java这样做是有意义的，因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储Strings。 

```java
List<Object> objectList;
List<String> stringList;
objectList = stringList;  //compilation error incompatible types
```

# 值传递
当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。
补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。

# 写一个单例类

单例模式主要作用是保证在Java应用程序中，一个类只有一个实例存在。下面给出两种不同形式的单例：
第一种形式：饿汉式单例

```java
public class Singleton {  
  private Singleton(){}  
  private static Singleton instance = new Singleton();  
  public static Singleton getInstance(){  
    return instance;  
  }  
}  
```

第二种形式：懒汉式单例
```java
public class Singleton {  
  private static Singleton instance = null;  
  private Singleton() {}  
  public static synchronized Singleton getInstance(){  
    if (instance==null) instance＝newSingleton();  
      return instance;  
    }  
  }
}  
```
单例的特点：外界无法通过构造器来创建对象，该类必须提供一个静态方法向外界提供该类的唯一实例。用Java进行服务器端编程时，使用单例模式的机会还是很多的，服务器上的资源都是很宝贵的，对于那些无状态的对象其实都可以单例化或者静态化（在内存中仅有唯一拷贝），如果使用了Spring这样的框架来进行对象托管，Spring的IoC容器在默认情况下对所有托管对象都是进行了单例化处理的。

# 列出一些你常见的运行时异常
* ArithmeticException（算术异常）
* ClassCastException （类转换异常）
* IllegalArgumentException （非法参数异常）
* IndexOutOfBoundsException （下表越界异常）
* NullPointerException （空指针异常）
* SecurityException （安全异常）

# 匿名内部类是否可以继承其它类，是否可以实现接口?
匿名的内部类是没有名字的内部类。不能extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现。

# 匿名内部类是否可以继承其它类？是否可以实现接口？
可以继承其他类或实现其他接口，在Swing编程中常用此方式来实现事件监听和回调。
（匿名内部类也就是没有名字的内部类正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口
基于一个抽象类：

```java
abstract class Person {
  public abstract void eat();
}
```
或者一个接口：
```java
interface Person {
  public void eat();
}
```
匿名内部类的具体实现：
...
```java
Person p = new Person() {
  public void eat() {
    System.out.println("eat something");  
  }
};
p.eat();
）
```

# 在Java中Lock接口比synchronized块的优势是什么？
你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。

# 如何实现对象克隆？
有两种方式：
* 实现Cloneable接口并重写Object类中的clone()方法；
* 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。
注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。


# 如何编写一个泛型方法，让它能接受泛型参数并返回泛型类型?
编写泛型方法并不困难，你需要用泛型类型来替代原始类型，比如使用T, E or K,V等被广泛认可的类型占位符。泛型方法的例子请参阅Java集合类框架。最简单的情况下，一个泛型方法可能会像这样: 

```java
public V put(K key, V value) {
  return cache.put(key, value);
}
```

# 如果main方法被声明为private会怎样？
能正常编译，但运行的时候会提示"main方法不是public的"。

# 当一个线程进入一个对象的synchronized方法之后，其它线程是否可进入此对象的synchronized方法？
不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。

# 怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？
```java
String s1 = "你好";
String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
```

# 打印昨天的当前时刻
```java
Calendar cal = Calendar.getInstance();  
cal.add(Calendar.DATE, -1);  
System.out.println(cal.getTime());  
```

# 抽象的方法是否可同时是静态的,是否可同时是本地方法，是否可同时被synchronized修饰?
都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。

# 抽象类和接口
抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。


# 指出下面程序的运行结果
```java
class A{  
  static{  
    System.out.print("1");    
  }  
  
  public A(){  
    System.out.print("2");  
  }  
}  
  
class B extends A{  
  static{  
    System.out.print("a");  
  }  
  
  public B(){  
    System.out.print("b");  
  }  
}  
  
public class Hello{  
  public static void main(String[] args){  
    A ab = new B();  
    ab = new B();  
  }  
}  
```
执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。 

# 日期和时间
* 如何取得年月日、小时分钟秒？
* 如何取得从1970年1月1日0时0分0秒到现在的毫秒数？
* 如何取得某月的最后一天？
* 如何格式化日期？
答：
* 创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值
* 以下方法均可获得该毫秒数:

```java
Calendar.getInstance().getTimeInMillis();  
System.currentTimeMillis(); 
```

* 示例代码如下: 
```java
Calendar time = Calendar.getInstance();  
time.getActualMaximum(Calendar.DAY_OF_MONTH);  
```
* 利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。

# 是否可以从一个静态方法内部发出对非静态方法的调用？
不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。

# 是否可以继承String类?
String 类是final类，不可以被继承。
补充：继承String本身就是一个错误的行为，对String类型最好的重用方式是关联（HAS-A）而不是继承（IS-A）。

# 构造器（constructor）是否可被重写（override）?
构造器不能被继承，因此不能被重写，但可以被重载。

# 简述synchronized和java.util.concurrent.locks.Lock的异同？
Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally 块中释放（这是释放外部资源的最好的地方）。

# 线程的基本状态以及状态之间的关系？ 
![image](/images/java_18.png)

除去起始（new）状态和结束（finished）状态，线程有三种状态，分别是：就绪（ready）、运行（running）和阻塞（blocked）。其中就绪状态代表线程具备了运行的所有条件，只等待CPU调度（万事俱备，只欠东风）；处于运行状态的线程可能因为CPU调度（时间片用完了）的原因回到就绪状态，也有可能因为调用了线程的yield方法回到就绪状态，此时线程不会释放它占有的资源的锁，坐等CPU以继续执行；运行状态的线程可能因为I/O中断、线程休眠、调用了对象的wait方法而进入阻塞状态（有的地方也称之为等待状态）；而进入阻塞状态的线程会因为休眠结束、调用了对象的notify方法或notifyAll方法或其他线程执行结束而进入就绪状态。注意：调用wait方法会让线程进入等待池中等待被唤醒，notify方法或notifyAll方法会让等待锁中的线程从等待池进入等锁池，在没有得到对象的锁之前，线程仍然无法获得CPU的调度和执行。

# 编写多线程程序有几种实现方式？
Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。
补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值

# 能不能自己写个类，也叫java.lang.String?
可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载jre.jar包中的那个java.lang.String。

# 解释内存中的栈（stack）、堆(heap)和静态存储区的用法
通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用内存中的栈空间；而通过new关键字和构造器创建的对象放在堆空间；程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟内存都可以被当成堆空间来使用。
String str = new String(“hello”);
上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，而“hello”这个字面量放在静态存储区。
补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上以提升对象的操作性能。
 (当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。Java对象总是在堆中分配的，因此Java对象的创建和回收对系统的开销是很大的。没有发生逃逸的对象由于生命周期都在一个方法体内，因此它们是可以在运行时栈上分配并销毁。)

# 请说出与线程同步相关的方法
* wait():使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
* sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；
* notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；
* notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争；
* JDK 1.5通过Lock接口提供了显式(explicit)的锁机制，增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁(unlock())的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；
* JDK 1.5还提供了信号量(semaphore)机制，信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。

# 运行时异常与受检异常有何异同
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，神作《Effective Java》中对异常的使用给出了以下指导原则：
* 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
* 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
* 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
* 优先使用标准的异常
* 每个方法抛出的异常都要有文档
* 保持异常的原子性
* 不要在catch中忽略掉捕获到的异常

# 静态内部类
`Static Nested Class`和`Inner Class`的不同
Nested Class （一般是C++的说法），Inner Class (一般是JAVA的说法)。Java内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。
注： 静态内部类（Inner Class）意味着
* 创建一个static内部类的对象，不需要一个外部类对象
* 不能从一个static内部类的一个对象访问一个外部类对象

# 静态初始化块
```java
static int nextId=1;
static
{
  Random ran=new Random();
  nextId=ran.nextInt(1000);
}
```

在类第一次被加载时，会进行静态初始化。
可利用这一点实现不用main方法就写出一个“Hello 
```
public class Hello
{
  static
  {
    System.out.println(“Hello,World”);
  }
  System.exit(0);
}
```

# 静态变量和实例变量的区别？
静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。

# 静态嵌套类和内部类
Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。


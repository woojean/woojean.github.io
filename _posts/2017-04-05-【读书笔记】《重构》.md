---
layout: post
title:  "《重构》读书笔记"
date: 2017-04-05 00:00:01
categories: 读书笔记
tags: 重构 设计模式
excerpt: ""
---

* content
{:toc}


## Add Parameters（添加参数）
当某个被修改后的函数需要从调用端得到更多信息，为此函数添加一个对象参数，让该对象带进函数所需的信息。

## Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）
两个类之间原有双向关联，但是现在其中一个类不再需要另一个类的特性，所以去除不必要的关联。

## Change Reference to Value（将引用对象改为值对象）
当有一个引用对象，很小且不可变，不易管理，将它改为一个值对象。

## Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）
当两个类都需要使用对方的特性，但其间只有一条单向连接时，添加一个反向指针，并使修改函数（改变双方关系的函数）能够同时更新两条连接。

## Change Value to Reference（将值对象改为引用对象）
当从一个类衍生出许多彼此相等的实例时，考虑将它们替换为同一个对象。

## Collapse Hierarchy（折叠继承体系）
当超类和子类之间无太大区别时，将它们合为一体。

## Consolidate Conditional Expression（合并条件表达式）
当有一系列条件测试都得到相同的结果（最终行为一致），可以将这些测试合并为一个条件表达式（使用逻辑或、逻辑与），并将这个条件表达式提炼为一个独立函数。

## Consolidate Duplicate Conditional Fragments（合并重复的条件片段）
在条件表达式的每个分支上有着相同的一段代码时，将这段重复代码搬移到条件表达式之外。

## Convert Procedural Design to Objects（将过程化设计转化为对象设计）
对于已有的传统过程化风格的代码，将数据记录变成对象，将大块的行为分为小块，并将行为移入相关对象之中。

## Decompose Conditional（分解条件表达式）
将条件表达式段落中的内容提炼为独立的函数。

## Duplicate Observed Data（复制被监视数据）
有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据时，将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。

## Encapsulate Collection（封装集合）
当一个函数返回一个集合时，让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。
取值函数不应该返回集合自身，因为这会让用户得以修改集合内容，而集合拥有者却一无所知。

## Encapsulate Downcast（封装向下转型）
当某个函数返回的对象需要由函数调用者执行向下转型时，将向下转型动作移到该函数中，并修改函数的返回类型。

## Encapsulate Field（封装字段）
将public字段声明为private，并提供相应的访问函数。

## Extract Class（提炼类）
某个类做了应该由两个类做的事，则建立一个新类，将相关的字段和函数从旧类搬移到新类。
如果某些数据和某些函数总是一起出现，某些数据经常同时变化甚至彼此相依，这就表示应该将它们分离出去。

## Extract Hierarchy（提炼继承体系）
当一个类做了太多工作，其中一部分工作是以大量条件表达式完成的。则建立继承体系，以一个子类表示一种特殊情况。

## Extract Interface（提炼接口）
当若干客户使用类接口中的同一子集，或者两个类的接口有部分相同时，将相同的子集提炼到一个独立接口中。

## Extract Method（提炼函数）
对于一段可以被组织在一起并独立出来的代码，将其放进一个独立函数中，并让函数名称解释该函数的用途。

## Extract Subclass（提炼子类）
当类中的某些特性只被某些（而非全部）实例用到时，新建一个子类，将这些特性移到子类中。

## Extract Superclass（提炼超类）
当两个类具有相似特性时，为这两个类建立一个超类，将相同特性移至超类。

## Form Template Method（塑造模板函数）
有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上有所不同时，将这些操作分别放进独立函数中，并保持它们都有相同的签名，然后将函数上移至超类。

## Hide Delegate（隐藏委托关系）
当客户类通过一个委托类来调用另一个对象时，在服务类上建立客户所需的所有函数，用以隐藏委托关系。
如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数，那么客户就必须知晓这一层委托关系，万一委托关系发生变化，客户也得相应变化，这不是好的封装，应该将这一层委托隐藏起来。

## Hide Method（隐藏函数）
对于未被其他任何类使用到的函数，将其修改为private。

## Inline Class（将类内联化）
当某个类没有做太多事情时，将这个类的所有特性搬移到另一个类中（该“萎缩类”的最频繁用户），然后移除原类。

## Inline Method（内联函数）
当一个函数的本体与名称同样清楚易懂时，在函数的调用点插入函数本体，然后移除该函数。

## Inline Temp（内联临时变量）
对于只被一个简单表达式赋值一次的临时变量，将对该变量的引用动作替换为对它赋值的那个表达式自身。

## Introduce Assertion（引入断言）
当某一段代码需要对程序状态做出某种假设时，以断言明确表现这种假设。

## Introduce Explaining Variable（引入解释性变量）
对于复杂的表达式（通常用于条件判断），将该复杂表达式（或其中一部分）的结果放进一个临时变量，并以此变量名称来解释表达式的用途。

## Introduce Foreign Method（引入外加函数）
有时需要为提供服务的类增加一个函数，但无法直接修改这个类。可以在客户类中建立一个函数，并以第一参数的形式传入一个服务类实例。

## Introduce Local Extension（引入本地扩展）
有时需要为提供服务的类增加一些函数，但无法直接修改这个类。可以建立一个新类，使它包含这些额外函数，然后将该类修改为服务类的子类或者包装类。

## Introduce Null Object（引入Null对象）
当需要再三检查某个对象是否为null时，将null值替换为null对象。为类新增isNull()方法，null对象的该方法返回true。

## Introduce Parameter Object（引入参数对象）
当某些参数总是同时出现时，以一个对象取代这些参数。

## Move Field（搬移字段）
当类的某个字段被另一个类更多地用到时，在目标类中新建一个字段，修改源字段的所有用户，令他们改用新字段。

## Move Method（搬移函数）
当类的某个函数和另一个类进行更多的交流：调用后者或者被后者调用时，在该函数最常引用的类中建立一个有着类似行为的新函数，将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。

## Parameterize Method（令函数携带参数）
当若干函数做了类似的工作，但是在函数体中使用了不同的值时，建立一个单一函数，并以参数表达那些不同的值。

## Preserve Whole Object（保持对象完整）
当从某个对象中取出若干值，并将它们作为某一次函数调用的参数时，改为传递整个对象。

## Pull Up Constructor Body（构造函数本体上移）
当在各个子类中拥有一些本体几乎完全一致的构造函数时，在超类中新建一个构造函数，并在子类构造函数中调用它。

## Pull Up Field（字段上移）
当两个子类拥有相同的字段时，将该字段移至超类。

## Pull Up Method（函数上移）
对于在各个子类中产生完全相同结果的函数，将其移至超类。

## Push Down Field（字段下移）
当超类中的某个字段只被部分（而非全部）子类用到时，将这个字段移到需要它的那些子类去。

## Push Down Method（函数下移）
当超类中的某个函数只与部分（而非全部）子类有关时，将这个函数移到相关的那些子类去。

## Remove Assignments to Parameters（移除对参数的赋值）
不要在函数体中对函数参数进行赋值，这会降低代码的清晰度，混用按值传递和按引用传递这两种参数传递方式。当函数中对形参进行赋值时，以一个临时变量取代该参数的位置（即新增一个临时变量，并将形参赋值给它，然后基于该临时变量进行操作）。

## Remove Control Flag（移除控制标记）
当在一系列布尔表达式中某个变量带有“控制标记”（比如用于控制是否继续循环）的作用时，以break语句或return语句取代控制标记。

## Remove Middle Man（移除中间人）
当某个类做了过多的简单委托动作时，让客户直接调用受托类。

## Remove Parameter（移除参数）
函数体中不再需要某个参数时，将该参数去除。

## Remove Setting Method（移除设值函数）
当类中的某个字段应该在对象创建时被设值，然后就不再改变时，去掉该字段的所有设置函数。

## Rename Method（函数改名）
当函数的名称未能揭示函数的用途时，修改函数的名称。

## Replace Array with Object（以对象取代数组）
当类中有一个数组，其中的元素各自代表不同的东西时，以对象替换数组，对于数组中的每个元素以一个字段来表示。

## Replace Conditional with Polymorphism（以多态取代条件表达式）
当有某个条件表达式，它根据对象类型的不同而选择不同的行为时，将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。

## Replace Constructor with Factory Method（以工厂函数取代构造函数）
当希望在创建对象时不仅仅是做简单的构建动作时，将构造函数替换为工厂函数。
如以工厂函数取代构造函数中的类型码参数。

## Replace Data Value with Object（以对象取代数据值）
当一个数据项需要与其他数据和行为一起使用才有意义时，将数据项变成对象。

## Replace Delegation with Inheritance（以继承取代委托）
当在两个类之间使用委托关系，并经常要为整个接口编写许多极其简单的委托函数时，让委托类继承受托类。

## Replace Error Code with Exception（以异常取代错误代码）
当某个函数返回一个特定的代码，用以表示某种错误时，改用抛出特定的异常。

## Replace Exception with Test（以测试取代异常）
对于一个调用者可以预先检查的条件，应该在使用调用函数之前先做检查，而不是抛出一个异常。

## Replace Inheritance with Delegation（以委托取代继承）
当某个类只使用超类接口中的一部分，或者根本不需要继承而来的数据时，在子类中新建一个字段用以保存超类，调整子类函数另它改而委托超类，然后去掉两者之间的继承关系。

## Replace Magic Number with Symbolic Constance（以字面常量取代魔法数）
当有一个字面数值带有特别的意义时，创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。

## Replace Method with Method Onject（以函数对象取代函数）
当有一个大型函数，其中的局部变量的使用阻碍了Extract Method重构方法时，将这个函数放进一个单独对象中，这样局部变量就成了对象内的字段，然后可以在同一个对象中将这个大型函数分解为多个小型函数。

## Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）
在一系列条件判断中，当某个条件极其罕见，就应该单独检查该条件，并在条件为真时立刻从函数中返回，这样的单独检查被称为卫语句。
函数中的条件逻辑使人难以看清正常的执行路径时，使用卫语句表现所有特殊情况。

## Replace Parameter with Explicit Methods（以明确函数取代参数）
当一个函数完全取决于参数值来采取不同的行为时，针对该参数的每一个可能值建立一个独立函数。

## Replace Parameter with Methods（以函数取代参数）
当对象调用某个函数，并将所得的结果作为参数传递给另一个函数，而接受该参数的函数本身也能够调用前一个函数时，让参数接受者去除该项函数，并直接调用前一个函数。

## Replace Record with Data Class（以数据类取代记录）
当需要面对传统编程环境中的记录结构时，为该记录创建一个“哑”数据对象。

## Replace Subclass with Fields（以字段取代子类）
当各个子类的唯一差别只在“返回常量数据”的函数身上时，修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类。

## Replace Temp with Query（以查询取代临时变量）
当程序以一个临时变量保存某一表达式的运算结果时，将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用，此后，新函数就可以被其他函数使用。

## Replace Type Code with Class（以类取代类型码）
当类中有一个数值类型码，但它不影响类的行为时，以一个新的类替换该数值类型码。

## Replace Type Code with State/Strategy（以State/Strategy取代类型码）
当类中有一个类型码，它会影响类的行为，但不能通过继承手法消除它时（比如类型码的值在对象生命周期中会发生变化），以状态对象取代类型码。

## Replace Type Code with Subclasses（以子类取代类型码）
当类中有一个类型码，它会影响类的行为，以子类取代这个类型码。

## Self Encapsulate Field（自封装字段）
不直接访问字段，而是为这个字段建立取值、设值函数，并且只以这些函数来访问字段。

## Separate Domain from Presentation（将领域和表述/显示分离）
当某些GUI类中包含了领域逻辑时，将领域逻辑分离出来，为它们建立独立的领域类。

## Separate Query from Modifier（将查询函数和修改函数分离）
当某个函数既返回对象状态值，又修改对象状态时，建立两个不同的函数，其中一个负责查询，另一个负责修改。

## Split Temporary Variable（分解临时变量）
当有一个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果时，针对每次赋值创造一个独立、对应的临时变量。

## Substitute Algorithm（替换算法）
将函数本体替换为另一个算法（保持形参列表、返回值不变）。

## Tease Apart Inheritance（梳理并分解继承体系）
当某个继承体系同时承担两项责任时，建立两个继承体系，并通过委托关系让其中一个可以调用另一个。


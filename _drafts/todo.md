关于线程继承关系图如下：
               USER VIEW
 <-- PID 43 --> <----------------- PID 42 ----------------->
                     +---------+
                     | process |
                    _| pid=42  |_
                  _/ | tgid=42 | \_ (new thread) _
       _ (fork) _/   +---------+                  \
      /                                        +---------+
+---------+                                    | process |
| process |                                    | pid=44  |
| pid=43  |                                    | tgid=42 |
| tgid=43 |                                    +---------+
+---------+
 <-- PID 43 --> <--------- PID 42 --------> <--- PID 44 --->
                     KERNEL VIEW

  

## ES6与ES5，this的变化比较（参考typescript文档 类类型）

# js 类静态部分与实例部分的区别（参考typescript文档 类类型）


## 使用Swoole后PHP开发的一些变化理解

使用Swoole扩展执行的PHP脚本需要预先在服务端执行（而不是每次访问时才会执行）。

比如程序中定义了一个类A，在传统模式下每次有用户访问时，类A都需要提前编译到内存中，1万次访问就要编译1万次。而用swoole则只需要在服务端编译一次，只要Swoole的进程存在，类A就会一直存在于内存中。

再比如PHP入门时就必须要掌握的session，对于运用了Swoole扩展的PHP程序而言，完全可以用一个变量来替换。

再比如：平时写PHP代码，完全不必担心内存使用，全局变量/函数/对象等，可以随便使用，因为PHP脚本执行结束后，内存自然会自行释放掉。但用Swoole扩展的PHP程序，则必然要手动注销全局的变量/函数/对象等。

PHP在fork子进程的时候，父进程的资源连接会被子进程获得，父进程本身会断掉。要解决这个问题只能在fork之后重新建连接。

一定不可以多进程或多线程共同一个mysql或redis连接，否则消息会串。每个进程或线程创建一个mysql的连接。连接断掉也就是mysql gone away之后进行重连。子进程退出后php引擎回清理回收所有的内存，关闭所有的连接。然后由于子进程和父进程共享内存，所以父进程里建立的连接等等也会被顺带关闭掉。

fpm本身是leader follower同步阻塞模型，同一时间只能处理一个请求，支持不了异步。


# 如何不直接使用include返回赋值实现将一个PHP文件的执行结果赋值到一个变量中？

用**输出控制函数**结合include来捕获其输出。
例：使用`输出缓冲`来将 PHP 文件包含入一个字符串

```php
<?php

function get_include_contents($filename) {
  if (is_file($filename)) {
    ob_start();
    include $filename;
    $contents = ob_get_contents();
    ob_end_clean();
    return $contents;
  }
  return false;
}

$string = get_include_contents('somefile.php');
```


专业书籍可以看看《组织行为学》，人大出版社的， 
以及人大劳人院的系列教材。这些是科普性质 系统化的讲解 
另外推荐彼得德鲁克的《卓有成效的管理者》管理学经典，总会有一个点触动你 
以及google的《work rules重新定义团队》打开管理思路 
  

  焦虑 = 未来的不确定性 x 事情的重要性 x 自己无能为力的程度。



一面，电话面试，面试官自我介绍是口碑的。

先让做自我介绍，这个不表。他手上应该有我猎聘网的简历。直接拿项目开问

#### Q1: 我看你在这家公司是负责购物车、订单这些模块的。那简单说下你们订单系统的流程。
A1: 
前端（H5／APP）发起订单创建申请，先落地这笔申请，然后分别入队：
1. 订单创建队列
2. 10分钟的订单下单状态纠错队列

分别用于
1. 处理下单逻辑，比如锁优惠券，锁库存等
3. 处理意外导致的订单最终状态不一致

如果一切OK，修改订单创建申请的状态，生成一条代付款订单记录，并且入队一条信息到订单超时未支付队列，用于在1小时后，用户仍然未付款，回复库存、优惠券等资源

前端在下完单后轮询订单创建申请状态，如果通过，就可以继续下一步操作，比如支付等。
支付完成以后，因为我们是做跨境电商，为了方便用户，我们会把这个订单buffer住3小时，方便3小时内用户取消订单。否则该笔订单推送至海关后，取消就比较麻烦

大致是这样

#### Q2: 下单流程中，你们如何处理锁优惠券，锁库存？
A2:
在异步下单处理中，分别调用各个子模块，并且记录已调用的模块。当某一个子模块同步操作失败（比如锁优惠券失败）时，分别调用已经调用过模块的回滚操作。
需要各个子模块配合订单系统的设计，提供锁定接口和回滚接口

#### Q3: 你是如何记录这些已经调用的模块？放在DB还是内存？
A3:
放内存

#### Q4: 如果这个时候内存丢失了，这笔订单如何处理？
A4:
之前说的10分钟下单状态纠错队列可以来处理这种问题。如果内存丢失，10分钟后，系统会判断该笔订单是否下单成功，如果没有，依此回滚可能调用到的所有业务

#### Q5: 能否这里再做优化？仅仅回滚调用过的模块。因为对于阿里这种流量巨大的系统，不必要的流程是要被优化掉的
A5:
那可以在每次调用一个模块后，插一条消息到队列，异步写入DB。这样，就算内存丢失，10分钟后的订单纠错仅需回滚DB里存在的模块

#### Q6: 说到锁，你知道乐观锁和悲观锁吗？
A6:
悲观锁就是拿数据前，会认为任何人都可能改变这个数据，因此需要进入之前加锁，操作完成后释放，比如一些数据库的行锁，表锁
乐观锁就是相反，会认为没有人会改变这个数据，拿数据的时候不上锁，写的时候再判断是否被其他人改变

#### Q7: 你说行锁和表锁，那什么情况下会出发行锁和表锁？
A7:
Mysql InnoDB里update一条记录会出发行锁。表锁的话，确实不清楚什么时候会触发，只知道显式的lock table会表锁

#### Q8: 之前听你说到锁库存，根据什么锁？如果有这样一种需求，类似于抢购，你会如何实现？
A8: 
根据订单code锁库存，库存系统保证幂等性。
如果是抢购，直接操作DB可能不太合适，可以在抢购开始前，将DB的数据同步到Redis，所有的操作都基于Redis的原子操作

#### Q9: 这样会不会发生超卖？如何和DB同步？那抢购中商家需要变更商品数量怎么办？如何避免超卖？
A9:
1. 如果抢购之前同步，基于redis的原子操作，不太可能超卖
2. 实时同步不太可能，可以商品被抢购后通过消息来异步同步DB
3. 比如商家将数量从50增加到70，那么此时需要将DB同步至redis,采用incr 20的原子操作，可以避免数据不同步发生超卖

#### Q10: 你们接的支付是什么支付？
A10: 
微信支付

#### Q11: 如果微信回调你失败了，你如何处理？
A11: 像前面说的超时未支付机制会处理，回滚所有占用的资源

#### Q12: 那比如有一件事情，需要一次执行1，2，3步，如何保证1，3发生错误回滚时2不回滚？事务的传播特性了解吗？
A12:
不了解（都没听说过）

#### Q13: 之前你说订单创建完成1小时后，你会检测用户是否付款，没有付款的话，你就去回滚优惠券、库存之类。那么，比如用户在下单后的59分59秒付款了，那这笔订单怎么办？
A13:
如果用户这时候付款，但是在1小时的时候，微信支付的回调可能还没到。这时订单会被认为超时未支付，去回滚所占用的资源。然后回调处理中发现订单已经被取消，就会去走自动退款流程

#### Q14: 这样是不是不合理？微信支付的回调一般多久，如果让你再优化下，你准备怎么做？
A14:
（这个问题确实没考虑到）我看过微信回调的log，基本在1分钟内会有回调。而且我们这边有一个java写的支付系统。那边会通过队列来保证失败重传。
我想可能把这个时间延迟一点，比如说用户1小时后就不能支付了，但真正的超时未支付处理放在5分钟以后，因为微信回调基本都在1分钟内完成

#### Q15: 一般点击下单后，前端会暂时禁止掉下单按钮，防止重复下单，如果前端此时不可控了。你的订单系统如何处理重复下单问题？
A15: 
在下单前，前端需要检测本地有没有一个ticket, 如果没有，请求服务器端，服务器端根据userId生成一个hset, value就是这个ticket。
用户在提交订单的时候，把这个ticket带进来，服务器端通过hdel判断该ticket是否有效，hdel返回成功，则有效，否则无效

#### Q16: 阿里的系统流量巨大，有什么办法处理这种高并发吗？如果对你现有的系统做优化支持高并发，你如何做？
A16: 我觉得可以这样:
1. 前端限流，只放5%-10%的流量进来
2. 将请求hash到多个队列中处理

#### Q17: 如果你们的公司现在订单量巨大，你们是否已经做了分表？
A17:
考虑过，但是按照订单的逻辑，订单code和userId是必须要做为分表属性的，因此可能不可避免的带来数据冗余。由于项目时间过紧，所有没有实施

#### Q18: 那有什么办法可以尽量减少冗余？比如说订单code和userId有一定关联？
A18:
（提示的太明显）可以将userId集成订单code中，这样无论是code和是userId都可以快速的路由到目标表

#### Q19: 负载均衡了解的多吗？如果发现系统中，就某一些用户极其活跃，导致所有的分表中，数据集中在某几个表里，这种情况如何处理？
A19:
(想了一会)确实不了解。据我目前了解的，分表的规则确定了，可能就比较难处理这种问题

#### Q20: 没事，那就再问最后一个业务问题，然后我们再面算法。如果你们的公司运营了几年，DB已经爆满，任何索引都增加不了性能了，如何处理？
A20:
对于这种冷数据，比如今年2017，很少会有用户查询2015年的订单。可以把这些订单按日期导入到其他库中。需要查询的时候，根据订单号去这些库中查询

#### Q21: 订单如何按照日期分？
A21: 我们的订单号里包含了年月日信息

#### Q22: 看你简历你一直写PHP的，了解PHP的内存管理机制吗？
A22:
（这个真不知道）因为PHP的内存回收机制比较完备，所以没有研究过这个方向

#### Q22-PS: 也就是只是用的比较多？你可以研究下，很有意思。

#### Q23: 好，那下面我们进入算法面试。第一题，将一个链表的奇数项和偶数项调换
A23:
(比较常见的算法题)拿笔在纸上写了下。大致如下:
```
struct *linkList trans(linkList *l)
{
    linkList i = l->next;
    linkList j = i->next;
    while (i && j) {
        linkList k = j->next;
        j->next = i;
        i->next = k;
        i = k;
        j = k->next;
    }
    return l;
}
```

#### Q24: 你这种解决方案无论对链表中数量是奇数还是偶数都正常工作吗？
A24:
是的。如果是奇数，那么j就是空，while条件不满足就直接返回了。

#### Q22: 第二题。找一个数组中之和最大的连续子数组
A22: 
(也比较常见了)。是个DP题，但是这种算法丢了很久了，都生疏了，所以第一想法仍然是遍历。思路如下：

1. 记录sum为当前和最大子数组之和
2. 遍历数组，如果sum+当前元素>sum，更新sum
3. 如果sum+当前元素<0,则sum置为0，即表示之前的sum肯定不是最大的（因为空数组也是子数组，空数组和为0）
4. 最后的sum就是最大子数组之和

代码大致如下：

```
int findMaxSubArray(int[] arr)
{
    int sum = 0;
    for ($i = 1; $i < arr.length; $i++) {
        if ($sum + $arr[$i] > $sum) {
            $sum += $arr[$i];
        } else if ($sum + $arr[$i] < 0) {
            $sum = 0;
        }
    }
    return $sum;
}
```

一面结束，整个时间大概在1个小时15分钟左右。压力较大。比较虚。感觉没有二面的机会了。






====================================
这是一篇反面教材，希望也能引起部分程序员的警惕。

最近半个月时间，经过几次面试，差不多已经对自己有了定位————距离腾讯T3岗位还是有一点距离。

因为在一家小公司呆的习惯了（6年），公司没有人在技术层面超过我，作为技术核心，感觉自己很牛，活在一个小圈子里面，几乎不会主动去了解新技术，甚至对php以及js本身都不能算精通。

所以变故出现的时候，我才发现自己的技术脱节有多厉害，虽然之前的面试并没有做专门的准备，但是与6年前找工作的情形相比，差距非常的大。

下面是我整理的一部分遇到的面试题，我尽量用我所知道的知识来进行陈述，肯定会有很多误解以及遗漏，希望大家能够指正。

公司1：

1、mysql_real_escape_string mysql_escape_string有什么本质的区别，有什么用处，为什么被弃用？

答：mysql_real_escape_string需要预先连接数据库，并可在第二个参数传入数据库连接（不填则使用上一个连接）

两者都是对数据库插入数据进行转义，但是mysql_real_escape_string转义时，会考虑数据库连接的字符集。

它们的用处都是用来能让数据正常插入到数据库中，并防止sql注入，但是并不能做到100%防止sql注入。

再问：为什么不能100%防止？

答；因为客户端编码以及服务器端编码不同，可能产生注入问题，但是其实这种场景不多见。

继续答：被弃用的原因是官方不再建议使用mysql_xx的数据库操作方式，建议使用pdo和mysqli，因为不管从性能跟安全来看，mysqli都比mysql要好。

衍生出来的问题是mysqli的连接复用（持久化）问题，这一块我并没有答好。

2、什么是内存泄漏，js内存泄漏是怎么产生的？

答：内存泄漏是因为一块被分配内存既不能被使用，也不能被回收，直到浏览器进程结束。

产生泄漏的原因是闭包维持函数内局部变量，不能被释放，尤其是使用闭包并存在外部引用还setInterval的时候危害很大。

备注：我觉得这块回答并不好，因为肯定不是闭包的原因。

我查了一下资料，从比较浅的方位来再回答一下这个问题：

产生泄漏的原因有好几种：

(1) 页面元素被删除，但是绑定在该元素上的事件未被删除；

(2) 闭包维持函数内局部变量（外部不可控），使其得不到释放；

(3) 意外的全局变量；

(4) 引用被删除，但是引用内的引用，还存在内存中。

从上述原因上看，内存泄漏产生的根本原因是引用无法正确回收，值类型并不能引发内存泄漏。

对于每个引用，都有自己的引用计数，当引用计数归零或被标记清除时，js垃圾回收器会认为该引用可以回收了。

3、什么是闭包，跟原型链、作用域链有什么关联

答：闭包是指存在于一个作用域链分支的函数域内的函数，该函数可以向上逐级访问作用域链上的变量，直到找到为止。当闭包存在外部引用时，js会维持闭包自身以及所在函数作用域链的内存状态。

备注：这个是我自己瞎说的。

继续答：跟原型链没有什么关联，函数的原型（prototype）主要用于实现继承，原型链可用于追溯继承关系，与作用域链类似，都是向上逐级访问属性，直到被找到，原型链的顶层是null，可以理解为所有的object都继承至null，所以null的类型是object。

继续答：作用域链可以看作是一个树形结构，由根节点window向下扩散，下层节点可以访问上层节点，但是上层节点无法访问下层节点，产生闭包的函数作用域属于节点中的一个，向下扩散后闭包函数产生叶子节点，叶子节点之间可以互相访问，当访问的变量在叶子节点中无法找到时，向上层节点查找，直到被找到为止，这个概念有点类似原型链上的属性查找。

4、一台电脑配置无限好，可以同时打开多少个网页

答：65535-1000 = 64535（端口数）

5、ip地址能被伪造吗？

答：http头部可以被篡改，但是只能修改X_FORWARDED_FOR，真实ip地址（REMOTE_ADDR）很难修改（除非是路由器去修改），因为真实ip是底层会话ip地址，而且因为TCP 3次握手的存在，连接无法建立，伪造的意义不大，至于UDP的话，一般是内网才使用UDP通信。

6、有100万个奖品，每个人可以中奖3次，先到先得，怎么控制并发，不能发超，并保证完全的先到先得模式

答：百万奖品在打乱后预先insert到数据库，所有中奖操作，均只能update，不能insert。进来抽奖的用户使用memcahe原子加锁，实现抽奖次数自增，当抽奖次数到达3时，返回不中奖。

再问：预先插入需要很多资源，如果奖品数量上了1亿怎么办？

答：使用redis队列存储请求，跑守护进程异步发奖，产生的问题是用户无法实时看到中奖情况。

再问：这样肯定不行。

再答：使用全局内存加锁确保抽奖过程是单进程在跑，但是会面临大并发阻塞问题。

再问：内存比较宝贵，在不用内存加锁的情况下怎么办，并且如果碰到1亿奖池的情况，预先插入数据库肯定不好，怎么办？

答：设置奖品概率，分三张表，都使用innodb引擎，一张存中奖记录（预先插入一行），一张存奖品发放概况，一张存用户抽奖情况（uin唯一索引），大并发情况下，利用mysql的排他锁进行并发控制。流程如下：

begin

查询用户抽奖次数，加排他锁

对用户抽奖次数的更新/插入

锁行查询发放情况

获得抽奖结果（某些奖品发完之后，动态变更概率）

更新发放表

插入中奖记录

commit

再问：遇到脏读怎么办？

答：这方面不是很了解

再问：innodb的master线程在什么情况下fork其他子线程？

答：不知道

7、数据链路层的数据是怎么校验的，有哪些校验方式？

答：crc32，别的校验可能是取模校验奇偶数吧。

备注：答个crc校验就行了。

8、b+树的查询时间复杂度是多少，哈希表是多少，为什么数据库索引用b+树存储，而不是哈希表，数据库索引存储还有其他数据结构吗？

答：O(log(n))，O(1)

因为哈希表是散列的，在遇到`key`>'12'这种查找条件时，不起作用，并且空间复杂度较高。

备注：b+数根据层数决定时间复杂度，数据量多的情况下一般4-5层，然后用二分法查找页中的数据，时间复杂度远小于log(n)。

9、apache是怎么跟php通讯的，sapi是什么

答：使用sapi通讯，sapi是php封装的对外数据传递接口，通常有cgi/fastcgi/cli/apache2handler四种运行模式。

10、php的垃圾回收机制？

答：垃圾回收是指当php运行状态结束时，比如遇到了exit/die/致命错误/脚本运行结束时，php需要回收运行过程中创建的变量、资源的内存。

ZEND引擎维护了一个栈zval，每个创建的变量和资源都会压入这个栈中，每个压入的数组结构都类似：[refcount => int, is_ref => 0|1, value => union, type => string]，变量被unset时，ref_count如果变成0，则被回收。

当遇到变量循环引用自身时，使用同步回收算法回收。

备注：PHP7已经重写了zal的结构体。

11、jquery的sizzle引擎工作原理

答：除了直到是DOM元素查找引擎之外，一无所知。

12、seajs的工作原理，如何解决重复加载库的问题，如何进行资源的同步加载

答：建立映射关系并缓存起来；资源并不能真正同步加载，只是返回一个回调。

13、memcache跟redis的区别

答：可存储数据结构不同；redis支持持久化存储。

14、md5逆向原理

答：先用字典查找，再尝试暴力破解。

再问：没有更好的方法了吗？

答：没有了。

备注：嗯，事实上也确实没有特别好的办法，只能使用TB级的海量特征库用数据库存起来，然再分片查找。

15、父类方法是protected，子类重构为private，会发生什么？

答：会发生fatal错误，因为继承的方法或属性只能维持或放大权限，不能缩小，比如protected重载为public是可行的。

16、一个网页从输入地址回车，到完整展示网页内容这段时间里，做了哪些工作，越详细越好。

答：

0、浏览器本地缓存匹配；

1、本地hosts映射对比;

2、本地dns缓存解析；

3、远程dns解析获得服务器ip地址；

4、浏览器发送tcp连接请求包(syn)；

5、请求包经过传输层、网络层、数据链路层封装通过网卡到达路由器；

6、路由器转发数据包到所属运营商服务器；

7、运营商服务器通过寻址最短路径通过中继节点到达指定ip地址；

8、服务器端可能存在反向代理或者负载均衡，都是直接转发请求至上游服务器，当然也可以制定安全防御规则直接丢弃请求包；

9、上游服务器收到连接请求，在自身可用的情况下，返回(syn+ack)；

10、浏览器校验ack，再次发送(syn+ack)；

11、服务器校验ack切换连接状态至established，然后根据请求传输数据包；

12、当transform-encoding为chunked时，浏览器开始渲染页面；

13、四次挥手，连接关闭；

14、渲染数据完成。

备注：还有很多东西不懂，一些东西完全是自己瞎蒙的，因为时间原因，以后有时间详细画一下。

17、keep-alive的概念

答：长连接机制，表示keep-alive-timeout时间内，如果连接没有closed，再次传输数据不再需要三次握手了。

备注：这里也有很多疑问，需要好好捋一捋。

18、linux文件压缩操作命令，shell脚本等

备注：因为平时开发都是在windows环境，对linux了解不足，这一块几乎是0分。

公司2：

这个是被鄙视最惨的一家了，首先会有笔试，相对来说并不复杂，但是有些坑，很多已经忘记了。

印象深刻的是我说自己熟悉常用设计模式，然后让我画UML类图，我就懵逼了，所以在写简历的时候，最好是写自己非常熟悉的，如果只是一知半解，并没有必要放到简历中。

公司3：

这里仅列举几个问到的问题：

1、设计一个中继服务器，转发客户A->客户B的请求；

2、myisam跟innodb有什么区别；

3、php进程死锁产生的原因是什么？怎么自动排查与自动恢复？

4、有class A { public function b($a, $b, $c){}};

怎么使用['b' => 2, 'a' => 1, 'c' => 3]，对进行A::b进行调用，并顺利赋值？

5、php5.2->php7.1的各版本演进历史，新增特性等？

6、画一个tcp三次握手图

目前还在找工作中，在我看来8年的程序员怎么也不应该是这样子的，温水煮青蛙的教训非常惨痛，好在现在认识到问题还不晚，等到了35岁这个年纪，可能就真的晚了。